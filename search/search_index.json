{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Agenkit","text":"<p>The foundation layer for AI agents.</p> <p>A production-ready framework for building distributed AI agent systems with cross-language support, comprehensive middleware, and full observability.</p> <p> </p>"},{"location":"#production-ready","title":"\ud83c\udf89 Production Ready","text":"<p>All 5 development phases complete:</p> <ul> <li>\u2705 Phase 1: Foundation &amp; Core (100%)</li> <li>\u2705 Phase 2: Transport Layer (100%)</li> <li>\u2705 Phase 3: Middleware &amp; Resilience (100%)</li> <li>\u2705 Phase 4: Testing &amp; Quality (100% - 137/137 tests passing)</li> <li>\u2705 Phase 5: DevOps &amp; Release (100% - Docker + Kubernetes ready)</li> </ul>"},{"location":"#key-features","title":"\u2728 Key Features","text":""},{"location":"#core-capabilities","title":"Core Capabilities","text":"<ul> <li>\ud83c\udfd7\ufe0f Minimal, Type-Safe Interfaces - Agent, Message, Tool primitives</li> <li>\ud83d\udd04 Orchestration Patterns - Sequential, Parallel, Router, Fallback, Conditional</li> <li>\ud83c\udf10 Cross-Language Support - Python \u2194 Go with full compatibility</li> <li>\ud83d\ude80 Multiple Transports - HTTP, gRPC, WebSocket</li> <li>\ud83d\udee1\ufe0f Production Middleware - Circuit breaker, retry, timeout, rate limiting, caching, batching</li> <li>\ud83d\udcca Full Observability - OpenTelemetry tracing, Prometheus metrics, structured logging</li> <li>\ud83d\udc33 Container Ready - Docker images and Kubernetes manifests</li> <li>\u26a1 High Performance - &lt;1% overhead, benchmarked and optimized</li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"PythonGoDocker <pre><code># Install\npip install agenkit\n</code></pre> <pre><code>from agenkit import Agent, Message\n\n# Create a simple agent\nclass MyAgent(Agent):\n    @property\n    def name(self) -&gt; str:\n        return \"my-agent\"\n\n    @property\n    def capabilities(self) -&gt; list[str]:\n        return [\"text-processing\"]\n\n    async def process(self, message: Message) -&gt; Message:\n        return Message(\n            role=\"agent\",\n            content=f\"Processed: {message.content}\"\n        )\n\n# Use it\nagent = MyAgent()\nresponse = await agent.process(Message(role=\"user\", content=\"Hello!\"))\nprint(response.content)  # \"Processed: Hello!\"\n</code></pre> <pre><code># Install\ngo get github.com/agenkit/agenkit-go\n</code></pre> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/agenkit/agenkit-go/agenkit\"\n)\n\ntype MyAgent struct{}\n\nfunc (a *MyAgent) Name() string {\n    return \"my-agent\"\n}\n\nfunc (a *MyAgent) Capabilities() []string {\n    return []string{\"text-processing\"}\n}\n\nfunc (a *MyAgent) Process(ctx context.Context, msg *agenkit.Message) (*agenkit.Message, error) {\n    return &amp;agenkit.Message{\n        Role:    \"agent\",\n        Content: fmt.Sprintf(\"Processed: %s\", msg.Content),\n    }, nil\n}\n\nfunc main() {\n    agent := &amp;MyAgent{}\n    msg := &amp;agenkit.Message{Role: \"user\", Content: \"Hello!\"}\n    response, _ := agent.Process(context.Background(), msg)\n    fmt.Println(response.Content) // \"Processed: Hello!\"\n}\n</code></pre> <pre><code># Start full stack (agents + observability)\ndocker-compose up -d\n\n# Access services\n# - Python agent: http://localhost:8080\n# - Go agent: http://localhost:8081\n# - Jaeger UI: http://localhost:16686\n# - Prometheus: http://localhost:9090\n</code></pre>"},{"location":"#learn-more","title":"\ud83d\udcda Learn More","text":"<ul> <li> <p> Getting Started</p> <p>New to Agenkit? Start here to learn the basics and build your first agent.</p> <p> Get started</p> </li> <li> <p> Architecture</p> <p>Understand the layered architecture and design principles behind Agenkit.</p> <p> Learn architecture</p> </li> <li> <p> Guides</p> <p>Step-by-step guides for Python, Go, cross-language communication, and deployment.</p> <p> Browse guides</p> </li> <li> <p> Examples</p> <p>28+ comprehensive examples covering all features and patterns.</p> <p> View examples</p> </li> </ul>"},{"location":"#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Application Layer                        \u2502\n\u2502  (Your agents, tools, and business logic)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Middleware Layer                            \u2502\n\u2502  Circuit Breaker \u2022 Retry \u2022 Timeout \u2022 Rate Limiter           \u2502\n\u2502  Caching \u2022 Batching \u2022 Tracing \u2022 Metrics                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Transport Layer                             \u2502\n\u2502  HTTP \u2022 gRPC \u2022 WebSocket \u2022 Protocol Adapters                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Core Interfaces                            \u2502\n\u2502  Agent \u2022 Message \u2022 Tool \u2022 Patterns                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#performance","title":"\ud83d\udcca Performance","text":"<p>Agenkit is designed for production use with minimal overhead:</p> <ul> <li>Go HTTP: 18.5x faster than Python (0.055ms vs 1.02ms)</li> <li>Middleware overhead: &lt;0.01% of total request time</li> <li>Transport overhead: &lt;1% in realistic LLM workloads</li> <li>Message scaling: 10,000x size = 190x latency (excellent efficiency)</li> </ul> <p>View detailed benchmarks \u2192</p>"},{"location":"#testing","title":"\ud83e\uddea Testing","text":"<p>Comprehensive test coverage with 137/137 tests passing (100%):</p> <ul> <li>47 tests - Cross-language integration (Python \u2194 Go)</li> <li>53 tests - Chaos engineering (network failures, crashes, slow responses)</li> <li>37 tests - Property-based testing (invariant validation)</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Check out our contributing guide to get started.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>Apache License 2.0 - See LICENSE for details.</p>"},{"location":"#links","title":"\ud83d\udd17 Links","text":"<ul> <li>GitHub: github.com/scttfrdmn/agenkit</li> <li>Issues: Report a bug</li> <li>Discussions: Join the discussion</li> </ul> <p>Built with \u2764\ufe0f by the Agenkit team</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to Agenkit!</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<p>There are many ways to contribute:</p> <ul> <li>Report bugs - Found a bug? Open an issue</li> <li>Suggest features - Have an idea? Start a discussion</li> <li>Improve docs - Fix typos, add examples, clarify explanations</li> <li>Write code - Fix bugs, add features, improve performance</li> <li>Share examples - Show us what you've built!</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"<pre><code># Fork on GitHub, then:\ngit clone https://github.com/YOUR_USERNAME/agenkit.git\ncd agenkit\n</code></pre>"},{"location":"contributing/#2-set-up-development-environment","title":"2. Set Up Development Environment","text":"PythonGo <pre><code># Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # or `venv\\Scripts\\activate` on Windows\n\n# Install in development mode\npip install -e \".[dev]\"\n\n# Run tests\npytest tests/\n</code></pre> <pre><code>cd agenkit-go\n\n# Download dependencies\ngo mod download\n\n# Run tests\ngo test ./...\n\n# Run linter\ngolangci-lint run\n</code></pre>"},{"location":"contributing/#3-create-a-branch","title":"3. Create a Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#1-make-changes","title":"1. Make Changes","text":"<ul> <li>Write code following our style guidelines (see below)</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> </ul>"},{"location":"contributing/#2-run-tests","title":"2. Run Tests","text":"PythonGo <pre><code># Run all tests\npytest tests/\n\n# Run specific test file\npytest tests/test_interfaces.py\n\n# Run with coverage\npytest tests/ --cov=agenkit --cov-report=html\n\n# Type checking\nmypy agenkit/\n\n# Linting\nruff check agenkit/ tests/\nblack --check agenkit/ tests/\n</code></pre> <pre><code># Run all tests\ngo test ./...\n\n# Run with coverage\ngo test ./... -coverprofile=coverage.out\ngo tool cover -html=coverage.out\n\n# Linting\ngolangci-lint run\n\n# Formatting\ngofmt -w .\n</code></pre>"},{"location":"contributing/#3-commit-changes","title":"3. Commit Changes","text":"<pre><code># Stage changes\ngit add .\n\n# Commit with descriptive message\ngit commit -m \"feat: add new middleware for X\"\n</code></pre> <p>Commit message format:</p> <pre><code>&lt;type&gt;: &lt;description&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation changes - <code>test</code>: Test additions/changes - <code>refactor</code>: Code refactoring - <code>perf</code>: Performance improvements - <code>chore</code>: Build/tooling changes</p>"},{"location":"contributing/#4-push-and-create-pr","title":"4. Push and Create PR","text":"<pre><code># Push to your fork\ngit push origin feature/your-feature-name\n\n# Create PR on GitHub\n</code></pre>"},{"location":"contributing/#code-style-guidelines","title":"Code Style Guidelines","text":""},{"location":"contributing/#python","title":"Python","text":"<ul> <li>PEP 8 compliant - Use <code>black</code> for formatting</li> <li>Type hints - All public APIs must have type hints</li> <li>Docstrings - Use Google-style docstrings</li> <li>mypy strict - Code must pass <code>mypy --strict</code></li> </ul> <pre><code>from typing import Any\n\nclass MyAgent(Agent):\n    \"\"\"\n    A sample agent that demonstrates style guidelines.\n\n    Args:\n        name: The agent name\n        config: Optional configuration dict\n\n    Example:\n        &gt;&gt;&gt; agent = MyAgent(\"my-agent\")\n        &gt;&gt;&gt; response = await agent.process(message)\n    \"\"\"\n\n    def __init__(self, name: str, config: dict[str, Any] | None = None):\n        self._name = name\n        self._config = config or {}\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Agent identifier.\"\"\"\n        return self._name\n\n    async def process(self, message: Message) -&gt; Message:\n        \"\"\"\n        Process a message and return a response.\n\n        Args:\n            message: Input message to process\n\n        Returns:\n            Response message\n\n        Raises:\n            ValueError: If message content is invalid\n        \"\"\"\n        # Implementation here\n        pass\n</code></pre>"},{"location":"contributing/#go","title":"Go","text":"<ul> <li>gofmt formatted - Always run <code>gofmt</code></li> <li>golangci-lint clean - Must pass linter</li> <li>Idiomatic Go - Follow effective Go guidelines</li> <li>Comments on exports - All exported items documented</li> </ul> <pre><code>// MyAgent is a sample agent that demonstrates style guidelines.\n//\n// Example:\n//\n//  agent := &amp;MyAgent{name: \"my-agent\"}\n//  response, err := agent.Process(ctx, message)\ntype MyAgent struct {\n    name   string\n    config map[string]interface{}\n}\n\n// Name returns the agent identifier.\nfunc (a *MyAgent) Name() string {\n    return a.name\n}\n\n// Process processes a message and returns a response.\nfunc (a *MyAgent) Process(ctx context.Context, msg *agenkit.Message) (*agenkit.Message, error) {\n    // Implementation here\n    return nil, nil\n}\n</code></pre>"},{"location":"contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"contributing/#test-coverage","title":"Test Coverage","text":"<ul> <li>New features: Must include tests</li> <li>Bug fixes: Must include regression test</li> <li>Coverage target: &gt;90% for new code</li> </ul>"},{"location":"contributing/#test-structure","title":"Test Structure","text":"PythonGo <pre><code>import pytest\nfrom agenkit import Agent, Message\n\nclass TestMyAgent:\n    \"\"\"Tests for MyAgent.\"\"\"\n\n    @pytest.fixture\n    def agent(self):\n        \"\"\"Create agent instance for testing.\"\"\"\n        return MyAgent(\"test-agent\")\n\n    @pytest.mark.asyncio\n    async def test_process_success(self, agent):\n        \"\"\"Test successful message processing.\"\"\"\n        message = Message(role=\"user\", content=\"test\")\n        response = await agent.process(message)\n\n        assert response.role == \"agent\"\n        assert \"test\" in response.content\n\n    @pytest.mark.asyncio\n    async def test_process_empty_message(self, agent):\n        \"\"\"Test handling of empty message.\"\"\"\n        message = Message(role=\"user\", content=\"\")\n\n        with pytest.raises(ValueError):\n            await agent.process(message)\n</code></pre> <pre><code>package mypackage_test\n\nimport (\n    \"context\"\n    \"testing\"\n    \"github.com/stretchr/testify/assert\"\n    \"github.com/stretchr/testify/require\"\n)\n\nfunc TestMyAgent_Process(t *testing.T) {\n    t.Run(\"success\", func(t *testing.T) {\n        agent := &amp;MyAgent{name: \"test-agent\"}\n        message := &amp;agenkit.Message{\n            Role:    \"user\",\n            Content: \"test\",\n        }\n\n        response, err := agent.Process(context.Background(), message)\n\n        require.NoError(t, err)\n        assert.Equal(t, \"agent\", response.Role)\n        assert.Contains(t, response.Content, \"test\")\n    })\n\n    t.Run(\"empty_message\", func(t *testing.T) {\n        agent := &amp;MyAgent{name: \"test-agent\"}\n        message := &amp;agenkit.Message{Role: \"user\", Content: \"\"}\n\n        _, err := agent.Process(context.Background(), message)\n\n        assert.Error(t, err)\n    })\n}\n</code></pre>"},{"location":"contributing/#documentation-guidelines","title":"Documentation Guidelines","text":"<ul> <li>Code comments: Explain WHY, not WHAT</li> <li>Docstrings: Required for all public APIs</li> <li>Examples: Include usage examples</li> <li>Diagrams: Use ASCII art or Mermaid for visuals</li> </ul>"},{"location":"contributing/#documentation-structure","title":"Documentation Structure","text":"<p>When updating docs:</p> <pre><code># Documentation site\ndocs-site/\n\u251c\u2500\u2500 getting-started/    # Tutorials and guides\n\u251c\u2500\u2500 core-concepts/      # Architecture and design\n\u251c\u2500\u2500 features/           # Feature documentation\n\u251c\u2500\u2500 guides/             # How-to guides\n\u251c\u2500\u2500 api/                # API reference\n\u2514\u2500\u2500 examples/           # Example code\n\n# Build and preview\nmkdocs serve\n# Visit http://localhost:8000\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Describe your changes</li> <li>What does this PR do?</li> <li>Why is it needed?</li> <li> <p>How does it work?</p> </li> <li> <p>Link related issues</p> </li> <li>Fixes #123</li> <li> <p>Relates to #456</p> </li> <li> <p>Add tests</p> </li> <li>New features require tests</li> <li> <p>Existing tests must pass</p> </li> <li> <p>Update documentation</p> </li> <li>Add/update docstrings</li> <li>Update relevant guides</li> <li> <p>Add examples if applicable</p> </li> <li> <p>Wait for review</p> </li> <li>Maintainers will review</li> <li>Address feedback</li> <li>Keep commits clean</li> </ol>"},{"location":"contributing/#code-review-checklist","title":"Code Review Checklist","text":"<p>Before requesting review, ensure:</p> <ul> <li> Tests pass (<code>pytest tests/</code> or <code>go test ./...</code>)</li> <li> Type checking passes (<code>mypy</code> or <code>go build</code>)</li> <li> Linting passes (<code>ruff</code>, <code>black</code> or <code>golangci-lint</code>)</li> <li> Documentation updated</li> <li> Examples added/updated if needed</li> <li> Commit messages follow convention</li> <li> PR description is clear</li> </ul>"},{"location":"contributing/#community-guidelines","title":"Community Guidelines","text":"<ul> <li>Be respectful - Treat everyone with respect</li> <li>Be constructive - Focus on the code, not the person</li> <li>Be patient - Maintainers are volunteers</li> <li>Be open - Consider other perspectives</li> <li>Be helpful - Help others when you can</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>GitHub Discussions: Ask a question</li> <li>GitHub Issues: Report a problem</li> </ul> <p>Thank you for contributing to Agenkit! \ud83c\udf89</p>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>Understanding Agenkit's fundamental concepts and design philosophy.</p>"},{"location":"core-concepts/#overview","title":"Overview","text":"<p>Agenkit is built on three core principles:</p> <ol> <li>Minimal Interfaces - Only what's required for interoperability</li> <li>Layered Architecture - Independent, composable layers</li> <li>Language Agnostic - Identical APIs across Python and Go</li> </ol>"},{"location":"core-concepts/#key-concepts","title":"Key Concepts","text":""},{"location":"core-concepts/#architecture","title":"Architecture","text":"<p>Learn how Agenkit's five layers work together to provide a complete agent framework.</p>"},{"location":"core-concepts/#interfaces","title":"Interfaces","text":"<p>Understand the core contracts: Agent, Message, Tool, and ToolResult.</p>"},{"location":"core-concepts/#design-principles","title":"Design Principles","text":"<p>Explore the philosophy behind Agenkit's design decisions.</p>"},{"location":"core-concepts/#the-foundation","title":"The Foundation","text":"<p>At its heart, Agenkit defines just four primitives:</p> <pre><code># 1. Agent - processes messages\nclass Agent:\n    def process(message: Message) -&gt; Message\n\n# 2. Message - universal data format\n@dataclass\nclass Message:\n    role: str\n    content: Any\n    metadata: dict\n\n# 3. Tool - executable functions\nclass Tool:\n    def execute(**kwargs) -&gt; ToolResult\n\n# 4. ToolResult - tool execution results\n@dataclass\nclass ToolResult:\n    success: bool\n    data: Any\n</code></pre> <p>Everything else in Agenkit builds on these four primitives.</p>"},{"location":"core-concepts/#design-philosophy","title":"Design Philosophy","text":"<p>\"Make the simple things simple, and the complex things possible.\"</p> <p>Agenkit achieves this through:</p> <ul> <li>Minimal core - Four interfaces, that's it</li> <li>Decorator pattern - Stack middleware like LEGO bricks</li> <li>Protocol adapters - Same interface, multiple transports</li> <li>Type safety - Full typing in both Python and Go</li> <li>Production ready - Error handling, observability, security</li> </ul>"},{"location":"core-concepts/#learning-path","title":"Learning Path","text":"<ol> <li>Start with Architecture to understand the big picture</li> <li>Deep dive into Interfaces to learn the contracts</li> <li>Review Design Principles for the philosophy</li> <li>Explore Features to see what's built on top</li> </ol> <p>Ready to dive in? Start with the Architecture Guide \u2192</p>"},{"location":"core-concepts/architecture/","title":"Architecture","text":"<p>Understanding Agenkit's layered architecture from the ground up.</p>"},{"location":"core-concepts/architecture/#overview","title":"Overview","text":"<p>Agenkit has a layered architecture where each layer is independent and composable. Every layer implements the same core <code>Agent</code> interface, enabling unlimited composability.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     YOUR APPLICATION                         \u2502\n\u2502  (Your agents, business logic, AI models)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 COMPOSITION LAYER                            \u2502\n\u2502  Sequential \u2022 Parallel \u2022 Router \u2022 Fallback \u2022 Conditional    \u2502\n\u2502  (Orchestrate multiple agents into workflows)               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 MIDDLEWARE LAYER                             \u2502\n\u2502  CircuitBreaker \u2022 Retry \u2022 Timeout \u2022 RateLimiter            \u2502\n\u2502  Caching \u2022 Batching \u2022 Tracing \u2022 Metrics                     \u2502\n\u2502  (Add resilience, observability, performance)               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 TRANSPORT LAYER                              \u2502\n\u2502  HTTP \u2022 gRPC \u2022 WebSocket \u2022 Local                            \u2502\n\u2502  (Enable cross-process, cross-language communication)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 CORE INTERFACES                              \u2502\n\u2502  Agent \u2022 Message \u2022 Tool \u2022 ToolResult                         \u2502\n\u2502  (The minimal contract everything implements)               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"core-concepts/architecture/#layer-1-core-interfaces","title":"Layer 1: Core Interfaces","text":"<p>Location: <code>agenkit/interfaces.py</code> (Python), <code>agenkit-go/agenkit/interfaces.go</code> (Go)</p> <p>This is the minimal contract that everything builds on. Only 4 primitives:</p>"},{"location":"core-concepts/architecture/#the-agent-interface","title":"The Agent Interface","text":"<pre><code>class Agent(ABC):\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"Agent identifier\"\"\"\n\n    @abstractmethod\n    async def process(self, message: Message) -&gt; Message:\n        \"\"\"Core method - process input, return output\"\"\"\n</code></pre> <p>That's it! An agent is just something with a name that can process messages.</p>"},{"location":"core-concepts/architecture/#the-message-data-class","title":"The Message Data Class","text":"<pre><code>@dataclass(frozen=True)\nclass Message:\n    role: str           # \"user\", \"agent\", \"system\", \"tool\"\n    content: Any        # Flexible - str, dict, list, anything\n    metadata: dict      # Extension point for custom data\n    timestamp: datetime # For ordering and debugging\n</code></pre>"},{"location":"core-concepts/architecture/#the-tool-interface","title":"The Tool Interface","text":"<pre><code>class Tool(ABC):\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"Tool identifier\"\"\"\n\n    @abstractmethod\n    async def execute(self, **kwargs) -&gt; ToolResult:\n        \"\"\"Execute the tool\"\"\"\n</code></pre>"},{"location":"core-concepts/architecture/#the-toolresult-data-class","title":"The ToolResult Data Class","text":"<pre><code>@dataclass(frozen=True)\nclass ToolResult:\n    success: bool       # Did it work?\n    data: Any          # The result\n    error: str | None  # Error message if failed\n</code></pre>"},{"location":"core-concepts/architecture/#design-principle-minimalism","title":"Design Principle: Minimalism","text":"<p>These interfaces are minimal - just enough for interoperability, nothing more. No framework opinions leak in. You can implement them with any LLM library, any framework, any infrastructure.</p>"},{"location":"core-concepts/architecture/#layer-2-transport-layer","title":"Layer 2: Transport Layer","text":"<p>Location: <code>agenkit/adapters/python/</code> (Python), <code>agenkit-go/adapter/</code> (Go)</p> <p>Enables agents to communicate across processes and across languages (Python \u2194 Go).</p>"},{"location":"core-concepts/architecture/#transport-types","title":"Transport Types","text":""},{"location":"core-concepts/architecture/#1-local-transport","title":"1. Local Transport","text":"<p>Same process, no serialization:</p> <pre><code>from agenkit.adapters.python.local_agent import LocalAgent\n\nlocal_agent = LocalAgent(my_agent)\nresponse = await local_agent.process(message)\n</code></pre>"},{"location":"core-concepts/architecture/#2-http-transport","title":"2. HTTP Transport","text":"<p>Remote agent over HTTP/1.1, HTTP/2, or HTTP/3:</p> <pre><code>from agenkit.adapters.python.remote_agent import RemoteAgent\n\nremote_agent = RemoteAgent(\n    name=\"python-agent\",\n    endpoint=\"http://localhost:8080\"\n)\nresponse = await remote_agent.process(message)\n</code></pre>"},{"location":"core-concepts/architecture/#3-grpc-transport","title":"3. gRPC Transport","text":"<p>High-performance binary protocol:</p> <pre><code>remote_agent = RemoteAgent(\n    name=\"go-agent\",\n    endpoint=\"grpc://localhost:50051\"\n)\n</code></pre>"},{"location":"core-concepts/architecture/#4-websocket-transport","title":"4. WebSocket Transport","text":"<p>Bidirectional streaming:</p> <pre><code>remote_agent = RemoteAgent(\n    name=\"streaming-agent\",\n    endpoint=\"ws://localhost:8080\"\n)\n</code></pre>"},{"location":"core-concepts/architecture/#how-transports-work","title":"How Transports Work","text":"<p>The <code>RemoteAgent</code> class implements the same <code>Agent</code> interface but forwards calls to a remote server:</p> <pre><code>class RemoteAgent(Agent):\n    def __init__(self, name: str, endpoint: str):\n        self._transport = self._create_transport(endpoint)\n\n    async def process(self, message: Message) -&gt; Message:\n        # 1. Serialize message\n        request_bytes = encode_message(message)\n\n        # 2. Send over transport (HTTP/gRPC/WebSocket)\n        response_bytes = await self._transport.send(request_bytes)\n\n        # 3. Deserialize response\n        return decode_message(response_bytes)\n</code></pre> <p>Key Point: From the caller's perspective, local and remote agents are identical - same interface!</p>"},{"location":"core-concepts/architecture/#cross-language-communication","title":"Cross-Language Communication","text":"Python \u2192 GoGo \u2192 Python <pre><code># Python calling Go agent\ngo_agent = RemoteAgent(\n    name=\"go-text-processor\",\n    endpoint=\"grpc://localhost:50051\"\n)\nresponse = await go_agent.process(message)\n</code></pre> <pre><code>// Go calling Python agent\npythonAgent := http.NewHTTPAgent(\n    \"python-analyzer\",\n    \"http://localhost:8080\",\n)\nresponse, _ := pythonAgent.Process(ctx, message)\n</code></pre>"},{"location":"core-concepts/architecture/#layer-3-middleware-layer","title":"Layer 3: Middleware Layer","text":"<p>Location: <code>agenkit/middleware/</code> (Python), <code>agenkit-go/middleware/</code> (Go)</p> <p>Middleware wraps agents to add cross-cutting concerns like error handling, metrics, caching, etc.</p>"},{"location":"core-concepts/architecture/#the-middleware-pattern","title":"The Middleware Pattern","text":"<p>Every middleware implements the <code>Agent</code> interface and wraps another agent:</p> <pre><code>class RetryDecorator(Agent):\n    def __init__(self, agent: Agent, config: RetryConfig):\n        self._agent = agent  # Wrap the inner agent\n        self._config = config\n\n    @property\n    def name(self) -&gt; str:\n        return self._agent.name  # Delegate to inner agent\n\n    async def process(self, message: Message) -&gt; Message:\n        # Add retry logic AROUND the inner agent\n        for attempt in range(self._config.max_attempts):\n            try:\n                return await self._agent.process(message)\n            except Exception as e:\n                if attempt == self._config.max_attempts - 1:\n                    raise\n                await asyncio.sleep(backoff)\n</code></pre>"},{"location":"core-concepts/architecture/#available-middleware","title":"Available Middleware","text":"Middleware Purpose Example RetryDecorator Exponential backoff with jitter <code>RetryDecorator(agent, RetryConfig(max_attempts=3))</code> CircuitBreaker Fail-fast pattern <code>CircuitBreaker(agent, CircuitBreakerConfig())</code> TimeoutDecorator Request deadline enforcement <code>TimeoutDecorator(agent, timeout=10.0)</code> RateLimiter Token bucket algorithm <code>RateLimiter(agent, requests_per_second=10)</code> CachingDecorator LRU cache with TTL <code>CachingDecorator(agent, max_size=1000, ttl=300)</code> BatchingDecorator Request aggregation <code>BatchingDecorator(agent, max_batch_size=10)</code> TracingMiddleware OpenTelemetry tracing <code>TracingMiddleware(agent)</code> MetricsMiddleware Prometheus metrics <code>MetricsMiddleware(agent)</code>"},{"location":"core-concepts/architecture/#stacking-middleware","title":"Stacking Middleware","text":"<p>Middleware is composable - you can stack them:</p> <pre><code># Start with base agent\nagent = MyAgent()\n\n# Add caching\nagent = CachingDecorator(agent, max_size=1000)\n\n# Add retry logic\nagent = RetryDecorator(agent, RetryConfig(max_attempts=3))\n\n# Add circuit breaker\nagent = CircuitBreaker(agent, CircuitBreakerConfig())\n\n# Add timeout\nagent = TimeoutDecorator(agent, timeout=30.0)\n\n# Add metrics\nagent = MetricsMiddleware(agent, service_name=\"my-service\")\n\n# Now use it - all middleware applies automatically!\nresponse = await agent.process(message)\n</code></pre>"},{"location":"core-concepts/architecture/#request-flow-through-middleware-stack","title":"Request Flow Through Middleware Stack","text":"<pre><code>Your Call\n    \u2193\nMetricsMiddleware (records metrics)\n    \u2193\nTimeoutDecorator (enforces deadline)\n    \u2193\nCircuitBreaker (checks if circuit is open)\n    \u2193\nRetryDecorator (retries on failure)\n    \u2193\nCachingDecorator (checks cache first)\n    \u2193\nMyAgent (your actual logic)\n    \u2193\nResponse flows back up\n</code></pre>"},{"location":"core-concepts/architecture/#layer-4-composition-layer","title":"Layer 4: Composition Layer","text":"<p>Location: <code>agenkit/composition/</code> (Python), <code>agenkit-go/composition/</code> (Go)</p> <p>Combine multiple agents into workflows. All composition patterns implement the Agent interface - so composed agents look like single agents!</p>"},{"location":"core-concepts/architecture/#1-sequential-pattern-pipeline","title":"1. Sequential Pattern (Pipeline)","text":"<p>Output of one agent becomes input of the next:</p> <pre><code>from agenkit.composition import SequentialAgent\n\n# Output of agent1 \u2192 input of agent2 \u2192 input of agent3\npipeline = SequentialAgent([agent1, agent2, agent3])\nresult = await pipeline.process(message)  # Flows through all 3\n</code></pre> <p>Use cases: Data pipelines, multi-stage processing, validation \u2192 processing \u2192 formatting</p>"},{"location":"core-concepts/architecture/#2-parallel-pattern-fan-out","title":"2. Parallel Pattern (Fan-out)","text":"<p>All agents process the SAME input concurrently:</p> <pre><code>from agenkit.composition import ParallelAgent\n\n# All agents process the SAME input concurrently\nparallel = ParallelAgent([sentiment_agent, summary_agent, translate_agent])\nresult = await parallel.process(message)  # All 3 run in parallel\n# result.content contains list of all responses\n</code></pre> <p>Use cases: Ensemble methods, multi-perspective analysis, redundant processing</p>"},{"location":"core-concepts/architecture/#3-fallback-pattern-high-availability","title":"3. Fallback Pattern (High Availability)","text":"<p>Try primary, fall back to secondary if it fails:</p> <pre><code>from agenkit.composition import FallbackAgent\n\n# Try primary, fall back to secondary if it fails\nha_agent = FallbackAgent([primary_agent, backup_agent, last_resort_agent])\nresult = await ha_agent.process(message)  # Uses first one that succeeds\n</code></pre> <p>Use cases: High availability, graceful degradation, multi-model fallback</p>"},{"location":"core-concepts/architecture/#4-conditional-pattern-router","title":"4. Conditional Pattern (Router)","text":"<p>Route to different agents based on condition:</p> <pre><code>from agenkit.composition import ConditionalAgent\n\ndef route(message: Message) -&gt; int:\n    if \"weather\" in message.content:\n        return 0  # weather_agent\n    elif \"news\" in message.content:\n        return 1  # news_agent\n    else:\n        return 2  # general_agent\n\nrouter = ConditionalAgent(\n    agents=[weather_agent, news_agent, general_agent],\n    condition=route\n)\n</code></pre> <p>Use cases: Intent routing, load balancing, A/B testing</p>"},{"location":"core-concepts/architecture/#composing-compositions","title":"Composing Compositions","text":"<p>Since compositions are agents, you can nest them:</p> <pre><code># Parallel analysis, then sequential refinement\nanalysis_parallel = ParallelAgent([sentiment, topics, entities])\nrefinement_sequential = SequentialAgent([analysis_parallel, summarizer, formatter])\n\n# Add retry + circuit breaker\nproduction_agent = CircuitBreaker(\n    RetryDecorator(refinement_sequential)\n)\n</code></pre>"},{"location":"core-concepts/architecture/#layer-5-observability","title":"Layer 5: Observability","text":"<p>Location: <code>agenkit/observability/</code> (Python), <code>agenkit-go/observability/</code> (Go)</p> <p>Built-in distributed tracing, metrics, and logging using OpenTelemetry.</p>"},{"location":"core-concepts/architecture/#distributed-tracing","title":"Distributed Tracing","text":"<pre><code>from agenkit.observability import init_tracing, TracingMiddleware\n\n# Initialize OpenTelemetry\ninit_tracing(\n    service_name=\"my-service\",\n    otlp_endpoint=\"http://jaeger:4317\"\n)\n\n# Wrap agent with tracing\ntraced_agent = TracingMiddleware(my_agent)\n\n# Every call now creates spans!\nresponse = await traced_agent.process(message)\n</code></pre> <p>Traces propagate across languages (Python \u2192 Go \u2192 Python) using W3C Trace Context!</p>"},{"location":"core-concepts/architecture/#prometheus-metrics","title":"Prometheus Metrics","text":"<pre><code>from agenkit.observability import init_metrics, MetricsMiddleware\n\n# Start Prometheus endpoint on :8001\ninit_metrics(service_name=\"my-service\", port=8001)\n\n# Wrap agent\nmetered_agent = MetricsMiddleware(my_agent)\n\n# Automatic metrics:\n# - agenkit_requests_total{agent=\"...\", status=\"...\"}\n# - agenkit_request_duration_seconds{agent=\"...\"}\n# - agenkit_message_size_bytes{agent=\"...\"}\n</code></pre>"},{"location":"core-concepts/architecture/#structured-logging","title":"Structured Logging","text":"<pre><code>from agenkit.observability import configure_logging\n\nconfigure_logging(\n    level=logging.INFO,\n    structured=True,  # JSON logs\n    include_trace_context=True  # Auto-inject trace_id, span_id\n)\n</code></pre>"},{"location":"core-concepts/architecture/#key-design-principles","title":"Key Design Principles","text":""},{"location":"core-concepts/architecture/#1-everything-is-an-agent","title":"1. Everything is an Agent","text":"<ul> <li>Middleware wraps agents and exposes Agent interface</li> <li>Compositions combine agents and expose Agent interface</li> <li>Remote agents proxy agents and expose Agent interface</li> <li>This means everything is composable!</li> </ul>"},{"location":"core-concepts/architecture/#2-minimal-interfaces","title":"2. Minimal Interfaces","text":"<ul> <li>Agent only needs <code>name</code> + <code>process()</code></li> <li>Message is just 4 fields</li> <li>No framework opinions, maximum flexibility</li> </ul>"},{"location":"core-concepts/architecture/#3-decorator-pattern","title":"3. Decorator Pattern","text":"<ul> <li>Middleware uses decorators (wrapping)</li> <li>Stack as many as you need</li> <li>Each adds one concern (Single Responsibility)</li> </ul>"},{"location":"core-concepts/architecture/#4-language-agnostic","title":"4. Language Agnostic","text":"<ul> <li>Python and Go have identical APIs</li> <li>Full cross-language compatibility</li> <li>Same patterns, same behavior</li> </ul>"},{"location":"core-concepts/architecture/#5-production-ready","title":"5. Production Ready","text":"<ul> <li>All 137 tests passing</li> <li>Comprehensive error handling</li> <li>Security hardened (non-root containers)</li> <li>Fully observable (traces, metrics, logs)</li> </ul>"},{"location":"core-concepts/architecture/#complete-example","title":"Complete Example","text":"<p>Putting it all together:</p> <pre><code>from agenkit import Agent, Message\nfrom agenkit.adapters.python.remote_agent import RemoteAgent\nfrom agenkit.middleware import RetryDecorator, CircuitBreaker, TimeoutDecorator\nfrom agenkit.observability import TracingMiddleware, MetricsMiddleware\nfrom agenkit.composition import ParallelAgent, SequentialAgent\n\n# Your custom agent\nclass MyAgent(Agent):\n    @property\n    def name(self) -&gt; str:\n        return \"my-agent\"\n\n    async def process(self, message: Message) -&gt; Message:\n        # Your logic here\n        return Message(role=\"agent\", content=\"Response\")\n\n# Remote Go agent (cross-language!)\ngo_agent = RemoteAgent(name=\"go-agent\", endpoint=\"grpc://localhost:50051\")\n\n# Parallel analysis\nanalysis = ParallelAgent([MyAgent(), go_agent])\n\n# Sequential pipeline\npipeline = SequentialAgent([analysis, MyAgent()])\n\n# Add production middleware\nproduction_agent = TracingMiddleware(      # Distributed tracing\n    MetricsMiddleware(                     # Prometheus metrics\n        TimeoutDecorator(                  # 30s timeout\n            CircuitBreaker(                # Fail-fast\n                RetryDecorator(            # 3 retries\n                    pipeline\n                )\n            ),\n            timeout=30.0\n        )\n    )\n)\n\n# Use it!\nresponse = await production_agent.process(\n    Message(role=\"user\", content=\"Hello!\")\n)\n</code></pre> <p>This gives you:</p> <ul> <li>\u2705 Cross-language communication (Python \u2194 Go)</li> <li>\u2705 Parallel + Sequential composition</li> <li>\u2705 Automatic retries with exponential backoff</li> <li>\u2705 Circuit breaker protection</li> <li>\u2705 30-second timeout enforcement</li> <li>\u2705 Prometheus metrics collection</li> <li>\u2705 Distributed tracing with Jaeger</li> </ul> <p>All with one simple interface: <code>await agent.process(message)</code>!</p>"},{"location":"core-concepts/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Interfaces - Deep dive into the core contracts</li> <li>Features - Explore each layer in detail</li> <li>Examples - See 28+ practical examples</li> <li>Guides - Build production systems</li> </ul>"},{"location":"core-concepts/design-principles/","title":"Design Principles","text":"<p>The philosophy behind Agenkit's architecture.</p>"},{"location":"core-concepts/design-principles/#core-philosophy","title":"Core Philosophy","text":"<p>\"Make the simple things simple, and the complex things possible.\"</p> <p>Agenkit achieves this through careful adherence to five core principles.</p>"},{"location":"core-concepts/design-principles/#1-minimal-interfaces","title":"1. Minimal Interfaces","text":"<p>Principle: Only what's REQUIRED for interoperability.</p>"},{"location":"core-concepts/design-principles/#what-this-means","title":"What This Means","text":"<ul> <li>Agent interface: Just <code>name</code> + <code>process()</code></li> <li>Message type: Just 4 fields</li> <li>Tool interface: Just <code>name</code> + <code>description</code> + <code>execute()</code></li> <li>ToolResult: Just <code>success</code> + <code>data</code> + <code>error</code></li> </ul>"},{"location":"core-concepts/design-principles/#why-this-matters","title":"Why This Matters","text":"<p>For framework builders: - Easy to implement - minimal contract to satisfy - No hidden requirements - No framework lock-in</p> <p>For users: - Easy to understand - less to learn - Easy to test - small surface area - Maximum flexibility</p>"},{"location":"core-concepts/design-principles/#counter-example","title":"Counter-Example","text":"<pre><code># \u274c What we DON'T do (bloated interface)\nclass Agent(ABC):\n    def name(self) -&gt; str: ...\n    def process(self, message: Message) -&gt; Message: ...\n    def get_config(self) -&gt; Config: ...\n    def set_config(self, config: Config): ...\n    def get_metrics(self) -&gt; Metrics: ...\n    def health_check(self) -&gt; bool: ...\n    def serialize(self) -&gt; bytes: ...\n    def deserialize(self, bytes) -&gt; Self: ...\n\n# \u2705 What we DO (minimal interface)\nclass Agent(ABC):\n    def name(self) -&gt; str: ...\n    def process(self, message: Message) -&gt; Message: ...\n</code></pre>"},{"location":"core-concepts/design-principles/#2-everything-is-an-agent","title":"2. Everything is an Agent","text":"<p>Principle: All layers implement the same Agent interface.</p>"},{"location":"core-concepts/design-principles/#what-this-means_1","title":"What This Means","text":"<ul> <li>Base agents: Implement Agent interface</li> <li>Middleware: Wraps Agent, exposes Agent interface</li> <li>Compositions: Combines Agents, exposes Agent interface</li> <li>Remote agents: Proxies Agent, exposes Agent interface</li> </ul>"},{"location":"core-concepts/design-principles/#why-this-matters_1","title":"Why This Matters","text":"<p>Unlimited composability:</p> <pre><code># All of these are agents\nbase = MyAgent()\ncached = CachingDecorator(base)\nretried = RetryDecorator(cached)\ntraced = TracingMiddleware(retried)\npipeline = SequentialAgent([traced, OtherAgent()])\nremote = RemoteAgent(endpoint=\"...\")\n\n# They all have the same interface!\nresponse = await any_agent.process(message)\n</code></pre> <p>Uniform APIs: - Same interface everywhere - No special cases - Easy mental model</p>"},{"location":"core-concepts/design-principles/#3-decorator-pattern-over-inheritance","title":"3. Decorator Pattern Over Inheritance","text":"<p>Principle: Composition over inheritance. Use wrappers, not subclasses.</p>"},{"location":"core-concepts/design-principles/#what-this-means_2","title":"What This Means","text":"<p>Instead of inheritance hierarchies:</p> <pre><code># \u274c Inheritance approach (rigid)\nclass RetryableAgent(Agent):\n    pass\n\nclass RetryableTimeoutAgent(RetryableAgent):\n    pass\n\nclass RetryableTimeoutCachingAgent(RetryableTimeoutAgent):\n    pass\n\n# Need 2^N classes for N features!\n</code></pre> <p>We use decoration:</p> <pre><code># \u2705 Decorator approach (flexible)\nagent = MyAgent()\nagent = RetryDecorator(agent)\nagent = TimeoutDecorator(agent)\nagent = CachingDecorator(agent)\n\n# Mix and match as needed!\n</code></pre>"},{"location":"core-concepts/design-principles/#why-this-matters_2","title":"Why This Matters","text":"<p>Flexibility: - Add/remove features at runtime - Change ordering dynamically - No class explosion</p> <p>Single Responsibility: - Each decorator does ONE thing - Easy to test independently - Easy to understand</p>"},{"location":"core-concepts/design-principles/#4-language-agnostic","title":"4. Language Agnostic","text":"<p>Principle: Identical APIs across Python and Go.</p>"},{"location":"core-concepts/design-principles/#what-this-means_3","title":"What This Means","text":"<p>The same patterns work in both languages:</p> PythonGo <pre><code>from agenkit import Agent, Message\nfrom agenkit.middleware import RetryDecorator\nfrom agenkit.composition import SequentialAgent\n\nagent = SequentialAgent([\n    RetryDecorator(Agent1()),\n    Agent2()\n])\n</code></pre> <pre><code>import (\n    \"github.com/agenkit/agenkit-go/agenkit\"\n    \"github.com/agenkit/agenkit-go/middleware\"\n    \"github.com/agenkit/agenkit-go/composition\"\n)\n\nagent := composition.NewSequentialAgent([]agenkit.Agent{\n    middleware.NewRetryDecorator(&amp;Agent1{}),\n    &amp;Agent2{},\n})\n</code></pre>"},{"location":"core-concepts/design-principles/#why-this-matters_3","title":"Why This Matters","text":"<p>Cross-language systems: - Python agent calls Go agent seamlessly - Same mental model, different languages - No impedance mismatch</p> <p>Polyglot teams: - Python devs understand Go code - Go devs understand Python code - Shared vocabulary and patterns</p>"},{"location":"core-concepts/design-principles/#5-production-ready-from-day-one","title":"5. Production Ready from Day One","text":"<p>Principle: Not a prototype. Not an experiment. Infrastructure.</p>"},{"location":"core-concepts/design-principles/#what-this-means_4","title":"What This Means","text":"<p>Code quality: - Type hints (mypy strict) - Comprehensive tests (137/137 passing) - Error handling on all paths - Security by default</p> <p>Observable: - OpenTelemetry tracing - Prometheus metrics - Structured logging - Health checks</p> <p>Deployable: - Docker images - Kubernetes manifests - Security hardened - Autoscaling ready</p>"},{"location":"core-concepts/design-principles/#why-this-matters_4","title":"Why This Matters","text":"<p>Trust: - Frameworks won't build on toy code - Production systems need production quality - 40-year veterans can spot shortcuts</p> <p>Longevity: - Good code compounds over time - Bad code becomes abandonware - Quality attracts quality</p>"},{"location":"core-concepts/design-principles/#design-trade-offs","title":"Design Trade-offs","text":"<p>Every design decision involves trade-offs. Here are ours:</p>"},{"location":"core-concepts/design-principles/#simplicity-vs-features","title":"Simplicity vs Features","text":"<p>Choice: Simplicity</p> <ul> <li>Minimal core interfaces</li> <li>Features built on top as optional layers</li> <li>You only pay for what you use</li> </ul> <p>Trade-off: Need to compose features yourself (but we provide examples!)</p>"},{"location":"core-concepts/design-principles/#performance-vs-flexibility","title":"Performance vs Flexibility","text":"<p>Choice: Both</p> <ul> <li>Hot path is direct method calls (&lt;5% overhead)</li> <li>No dynamic dispatch</li> <li>Single allocation per message</li> <li>But still flexible (Any type for content)</li> </ul> <p>Trade-off: None! We achieve both through careful design.</p>"},{"location":"core-concepts/design-principles/#type-safety-vs-dynamism","title":"Type Safety vs Dynamism","text":"<p>Choice: Type safety</p> <ul> <li>Full typing in Python and Go</li> <li>mypy strict mode compliant</li> <li>No <code>Any</code> where we can avoid it</li> </ul> <p>Trade-off: Slightly more verbose (but saves debugging time!)</p>"},{"location":"core-concepts/design-principles/#anti-patterns-we-avoid","title":"Anti-Patterns We Avoid","text":""},{"location":"core-concepts/design-principles/#1-framework-lock-in","title":"1. Framework Lock-In","text":"<p>\u274c Don't: Require users to subclass framework classes</p> <pre><code># Bad - user must inherit from our base\nclass MyAgent(AgenkitBaseAgent):\n    pass\n</code></pre> <p>\u2705 Do: Let users implement minimal interface</p> <pre><code># Good - user implements interface\nclass MyAgent(Agent):  # ABC, not concrete class\n    pass\n</code></pre>"},{"location":"core-concepts/design-principles/#2-hidden-magic","title":"2. Hidden Magic","text":"<p>\u274c Don't: Auto-register, auto-discover, metaclass magic</p> <pre><code># Bad - magic registration\n@register_agent  # Where does this go?\nclass MyAgent(Agent):\n    pass\n</code></pre> <p>\u2705 Do: Explicit is better than implicit</p> <pre><code># Good - explicit registration\nagent = MyAgent()\nregistry.register(agent)\n</code></pre>"},{"location":"core-concepts/design-principles/#3-leaky-abstractions","title":"3. Leaky Abstractions","text":"<p>\u274c Don't: Expose transport details in agent interface</p> <pre><code># Bad - HTTP details leak through\nagent.process(message, headers={\"X-Custom\": \"value\"})\n</code></pre> <p>\u2705 Do: Keep abstractions clean</p> <pre><code># Good - transport details in metadata\nmessage = Message(\n    role=\"user\",\n    content=\"...\",\n    metadata={\"http_headers\": {\"X-Custom\": \"value\"}}\n)\nagent.process(message)\n</code></pre>"},{"location":"core-concepts/design-principles/#influences","title":"Influences","text":"<p>Agenkit's design is influenced by:</p> <ul> <li>UNIX philosophy: Do one thing well, compose tools</li> <li>Go interfaces: Small, focused contracts</li> <li>Middleware pattern: Express, WSGI, Ring</li> <li>Reactive streams: Backpressure, composition</li> <li>gRPC/Protocol Buffers: Language-agnostic contracts</li> </ul>"},{"location":"core-concepts/design-principles/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture - See these principles in action</li> <li>Interfaces - Study the minimal contracts</li> <li>Examples - Learn by example</li> </ul>"},{"location":"core-concepts/interfaces/","title":"Core Interfaces","text":"<p>Deep dive into Agenkit's four core interfaces.</p>"},{"location":"core-concepts/interfaces/#overview","title":"Overview","text":"<p>Agenkit defines exactly 4 interfaces:</p> <ol> <li>Agent - Processes messages</li> <li>Message - Universal data format</li> <li>Tool - Executable functions</li> <li>ToolResult - Tool execution results</li> </ol> <p>That's it. Everything else is built on top of these four primitives.</p>"},{"location":"core-concepts/interfaces/#the-agent-interface","title":"The Agent Interface","text":"<p>The Agent interface is the heart of Agenkit. It defines a single contract: process messages.</p> PythonGo <pre><code>from abc import ABC, abstractmethod\nfrom agenkit.interfaces import Message\n\nclass Agent(ABC):\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"Unique agent identifier.\"\"\"\n        pass\n\n    @abstractmethod\n    async def process(self, message: Message) -&gt; Message:\n        \"\"\"Process a message and return a response.\"\"\"\n        pass\n\n    # Optional methods\n    async def stream(self, message: Message) -&gt; AsyncIterator[Message]:\n        \"\"\"Stream response messages (override if supported).\"\"\"\n        raise NotImplementedError\n\n    @property\n    def capabilities(self) -&gt; list[str]:\n        \"\"\"What this agent can do (override if meaningful).\"\"\"\n        return []\n</code></pre> <pre><code>package agenkit\n\ntype Agent interface {\n    // Required methods\n    Name() string\n    Process(ctx context.Context, msg *Message) (*Message, error)\n\n    // Optional methods\n    Capabilities() []string\n}\n</code></pre>"},{"location":"core-concepts/interfaces/#required-methods","title":"Required Methods","text":"Method Purpose Returns <code>name</code> Unique identifier for the agent <code>str</code> (Python) / <code>string</code> (Go) <code>process(message)</code> Core processing logic <code>Message</code>"},{"location":"core-concepts/interfaces/#optional-methods","title":"Optional Methods","text":"Method Purpose Returns <code>stream(message)</code> Stream responses incrementally <code>AsyncIterator[Message]</code> <code>capabilities</code> List of capabilities <code>list[str]</code>"},{"location":"core-concepts/interfaces/#the-message-type","title":"The Message Type","text":"<p>Message is the universal data format for agent communication.</p> PythonGo <pre><code>from dataclasses import dataclass, field\nfrom datetime import datetime, timezone\nfrom typing import Any\n\n@dataclass(frozen=True)\nclass Message:\n    role: str\n    content: Any\n    metadata: dict[str, Any] = field(default_factory=dict)\n    timestamp: datetime = field(\n        default_factory=lambda: datetime.now(timezone.utc)\n    )\n</code></pre> <pre><code>type Message struct {\n    Role      string\n    Content   interface{}\n    Metadata  map[string]interface{}\n    Timestamp time.Time\n}\n</code></pre>"},{"location":"core-concepts/interfaces/#fields","title":"Fields","text":"Field Type Description <code>role</code> <code>str</code> Message source: <code>\"user\"</code>, <code>\"agent\"</code>, <code>\"system\"</code>, <code>\"tool\"</code> <code>content</code> <code>Any</code> Flexible content - string, dict, list, or any serializable type <code>metadata</code> <code>dict</code> Extension point for custom data (trace IDs, timestamps, etc.) <code>timestamp</code> <code>datetime</code> UTC timestamp for ordering and debugging"},{"location":"core-concepts/interfaces/#design-decisions","title":"Design Decisions","text":"<p>Why frozen/immutable? - Thread safety - Cacheable - Prevents accidental mutation</p> <p>Why Any for content? - Maximum flexibility - Agents decide their data format - No serialization constraints</p> <p>Why metadata dict? - Framework extensions don't change Message - Observability data (trace IDs, span IDs) - Custom application data</p>"},{"location":"core-concepts/interfaces/#common-roles","title":"Common Roles","text":"Role Used By Example <code>\"user\"</code> Human input <code>Message(role=\"user\", content=\"Hello\")</code> <code>\"agent\"</code> Agent responses <code>Message(role=\"agent\", content=\"Response\")</code> <code>\"system\"</code> System prompts <code>Message(role=\"system\", content=\"Instructions\")</code> <code>\"tool\"</code> Tool results <code>Message(role=\"tool\", content=tool_result)</code>"},{"location":"core-concepts/interfaces/#the-tool-interface","title":"The Tool Interface","text":"<p>Tools are executable functions that agents can use.</p> PythonGo <pre><code>from abc import ABC, abstractmethod\nfrom agenkit.interfaces import ToolResult\n\nclass Tool(ABC):\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"Tool identifier (must be unique).\"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def description(self) -&gt; str:\n        \"\"\"What this tool does (used by LLMs).\"\"\"\n        pass\n\n    @abstractmethod\n    async def execute(self, **kwargs: Any) -&gt; ToolResult:\n        \"\"\"Execute the tool with given parameters.\"\"\"\n        pass\n\n    # Optional methods\n    @property\n    def parameters_schema(self) -&gt; dict[str, Any] | None:\n        \"\"\"JSON schema for tool parameters.\"\"\"\n        return None\n\n    async def validate(self, **kwargs: Any) -&gt; bool:\n        \"\"\"Validate inputs before execution.\"\"\"\n        return True\n</code></pre> <pre><code>type Tool interface {\n    Name() string\n    Description() string\n    Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error)\n}\n</code></pre>"},{"location":"core-concepts/interfaces/#example-calculator-tool","title":"Example: Calculator Tool","text":"PythonGo <pre><code>class CalculatorTool(Tool):\n    @property\n    def name(self) -&gt; str:\n        return \"calculator\"\n\n    @property\n    def description(self) -&gt; str:\n        return \"Perform mathematical calculations\"\n\n    async def execute(self, expression: str) -&gt; ToolResult:\n        try:\n            result = eval(expression)  # DON'T DO THIS IN PRODUCTION!\n            return ToolResult(success=True, data=result)\n        except Exception as e:\n            return ToolResult(success=False, data=None, error=str(e))\n</code></pre> <pre><code>type CalculatorTool struct{}\n\nfunc (t *CalculatorTool) Name() string {\n    return \"calculator\"\n}\n\nfunc (t *CalculatorTool) Description() string {\n    return \"Perform mathematical calculations\"\n}\n\nfunc (t *CalculatorTool) Execute(ctx context.Context, params map[string]interface{}) (*ToolResult, error) {\n    // Implementation here\n    return &amp;ToolResult{Success: true, Data: result}, nil\n}\n</code></pre>"},{"location":"core-concepts/interfaces/#the-toolresult-type","title":"The ToolResult Type","text":"<p>ToolResult represents the outcome of tool execution.</p> PythonGo <pre><code>@dataclass(frozen=True)\nclass ToolResult:\n    success: bool\n    data: Any\n    error: str | None = None\n    metadata: dict[str, Any] = field(default_factory=dict)\n</code></pre> <pre><code>type ToolResult struct {\n    Success  bool\n    Data     interface{}\n    Error    *string\n    Metadata map[string]interface{}\n}\n</code></pre>"},{"location":"core-concepts/interfaces/#fields_1","title":"Fields","text":"Field Type Description <code>success</code> <code>bool</code> Did the tool execute successfully? <code>data</code> <code>Any</code> The result data (if successful) <code>error</code> <code>str \\| None</code> Error message (if failed) <code>metadata</code> <code>dict</code> Execution details (timing, resource usage, etc.)"},{"location":"core-concepts/interfaces/#design-explicit-successfailure","title":"Design: Explicit Success/Failure","text":"<p>Instead of using exceptions, ToolResult uses explicit success/failure:</p> <pre><code># Good - explicit success/failure\nresult = await tool.execute(query=\"test\")\nif result.success:\n    print(result.data)\nelse:\n    print(f\"Error: {result.error}\")\n\n# Bad - exception-based (NOT used)\ntry:\n    result = await tool.execute(query=\"test\")\nexcept ToolExecutionError as e:\n    print(f\"Error: {e}\")\n</code></pre> <p>Why? - Errors are data, not control flow - Easier to serialize across network - Forces callers to handle failures - No hidden exceptions</p>"},{"location":"core-concepts/interfaces/#interface-guarantees","title":"Interface Guarantees","text":""},{"location":"core-concepts/interfaces/#type-safety","title":"Type Safety","text":"<p>All interfaces are fully typed in both Python and Go:</p> PythonGo <pre><code># mypy strict mode compliant\nagent: Agent = MyAgent()\nmessage: Message = Message(role=\"user\", content=\"test\")\nresponse: Message = await agent.process(message)\n</code></pre> <pre><code>// Full type checking\nvar agent agenkit.Agent = &amp;MyAgent{}\nmessage := &amp;agenkit.Message{Role: \"user\", Content: \"test\"}\nresponse, err := agent.Process(ctx, message)\n</code></pre>"},{"location":"core-concepts/interfaces/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Agent interface overhead: &lt;5% (benchmarked)</li> <li>Message creation: Single allocation</li> <li>Hot path: Direct method call, no dynamic dispatch</li> <li>Tool execution: No metaclass magic, no reflection</li> </ul>"},{"location":"core-concepts/interfaces/#backward-compatibility","title":"Backward Compatibility","text":"<p>These interfaces are stable. Changes will be:</p> <ol> <li>Additive only - New optional methods may be added</li> <li>Deprecated gradually - Old methods marked deprecated for 2+ versions</li> <li>Versioned - Major version bump for breaking changes</li> </ol>"},{"location":"core-concepts/interfaces/#implementation-examples","title":"Implementation Examples","text":""},{"location":"core-concepts/interfaces/#minimal-agent","title":"Minimal Agent","text":"PythonGo <pre><code>class MinimalAgent(Agent):\n    @property\n    def name(self) -&gt; str:\n        return \"minimal\"\n\n    async def process(self, message: Message) -&gt; Message:\n        return Message(role=\"agent\", content=\"OK\")\n</code></pre> <pre><code>type MinimalAgent struct{}\n\nfunc (a *MinimalAgent) Name() string {\n    return \"minimal\"\n}\n\nfunc (a *MinimalAgent) Process(ctx context.Context, msg *Message) (*Message, error) {\n    return &amp;Message{Role: \"agent\", Content: \"OK\"}, nil\n}\n</code></pre>"},{"location":"core-concepts/interfaces/#stateful-agent","title":"Stateful Agent","text":"PythonGo <pre><code>class StatefulAgent(Agent):\n    def __init__(self):\n        self.request_count = 0\n\n    @property\n    def name(self) -&gt; str:\n        return \"stateful\"\n\n    async def process(self, message: Message) -&gt; Message:\n        self.request_count += 1\n        return Message(\n            role=\"agent\",\n            content=f\"Request #{self.request_count}\",\n            metadata={\"count\": self.request_count}\n        )\n</code></pre> <pre><code>type StatefulAgent struct {\n    requestCount int\n    mu           sync.Mutex\n}\n\nfunc (a *StatefulAgent) Process(ctx context.Context, msg *Message) (*Message, error) {\n    a.mu.Lock()\n    a.requestCount++\n    count := a.requestCount\n    a.mu.Unlock()\n\n    return &amp;Message{\n        Role:    \"agent\",\n        Content: fmt.Sprintf(\"Request #%d\", count),\n        Metadata: map[string]interface{}{\"count\": count},\n    }, nil\n}\n</code></pre>"},{"location":"core-concepts/interfaces/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture - See how these interfaces compose into layers</li> <li>Design Principles - Understand the \"why\" behind these choices</li> <li>Examples - See 28+ implementations</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>28+ comprehensive examples covering all Agenkit features.</p>"},{"location":"examples/#overview","title":"Overview","text":"<p>Our examples demonstrate real-world usage patterns with:</p> <ul> <li>Complete code - Ready to run</li> <li>Explanations - Why, not just what</li> <li>Best practices - Production patterns</li> <li>Both languages - Python and Go</li> </ul>"},{"location":"examples/#quick-start-examples","title":"Quick Start Examples","text":"<p>New to Agenkit? Start here:</p> <ol> <li>01_basic_agent.py - Create your first agent</li> <li>02_sequential_pattern.py - Chain agents in a pipeline</li> <li>03_parallel_pattern.py - Run agents concurrently</li> </ol>"},{"location":"examples/#examples-by-category","title":"Examples by Category","text":""},{"location":"examples/#core-patterns-6-examples","title":"Core Patterns (6 examples)","text":"<p>Basic agent creation and composition patterns.</p> Example Description Python Go Basic Agent Simple message processing \ud83d\udcc4 \ud83d\udcc4 Sequential Pattern Pipeline processing \ud83d\udcc4 \ud83d\udcc4 Parallel Pattern Concurrent execution \ud83d\udcc4 \ud83d\udcc4 Router Pattern Conditional dispatch \ud83d\udcc4 - Tool Usage Tool integration \ud83d\udcc4 \ud83d\udcc4 Pattern Composition Complex workflows \ud83d\udcc4 -"},{"location":"examples/#transport-layer-3-examples","title":"Transport Layer (3 examples)","text":"<p>Cross-process and cross-language communication.</p> Example Description Python Go WebSocket Bidirectional streaming \ud83d\udcc4 \ud83d\udcc4 gRPC High-performance RPC \ud83d\udcc4 \ud83d\udcc4"},{"location":"examples/#middleware-6-examples","title":"Middleware (6 examples)","text":"<p>Production resilience and observability.</p> Example Description Python Go Circuit Breaker Fail-fast pattern \ud83d\udcc4 \ud83d\udcc4 Retry Exponential backoff \ud83d\udcc4 \ud83d\udcc4 Timeout Request deadlines \ud83d\udcc4 \ud83d\udcc4 Rate Limiter Token bucket \ud83d\udcc4 \ud83d\udcc4 Caching LRU cache with TTL \ud83d\udcc4 \ud83d\udcc4 Batching Request aggregation \ud83d\udcc4 \ud83d\udcc4"},{"location":"examples/#composition-patterns-4-examples","title":"Composition Patterns (4 examples)","text":"<p>Advanced multi-agent orchestration.</p> Example Description Python Go Sequential Advanced pipelines \ud83d\udcc4 \ud83d\udcc4 Parallel Result aggregation \ud83d\udcc4 \ud83d\udcc4 Fallback High availability \ud83d\udcc4 \ud83d\udcc4 Conditional Dynamic routing \ud83d\udcc4 \ud83d\udcc4"},{"location":"examples/#tools-4-examples","title":"Tools (4 examples)","text":"<p>Tool integration and function calling.</p> Example Description Python Go Calculator Math operations \ud83d\udcc4 \ud83d\udcc4 Search External API calls \ud83d\udcc4 - Database Database operations \ud83d\udcc4 - OS Tools File system &amp; processes \ud83d\udcc4 -"},{"location":"examples/#adapters-3-examples","title":"Adapters (3 examples)","text":"<p>Remote agents and streaming.</p> Example Description Python Go Basic Remote Cross-process agents \ud83d\udcc4 - Agent Registry Service discovery \ud83d\udcc4 - Streaming Stream processing \ud83d\udcc4 -"},{"location":"examples/#observability-2-examples","title":"Observability (2 examples)","text":"<p>Tracing, metrics, and logging.</p> Example Description Python Go Full Stack Complete observability \ud83d\udcc4 \ud83d\udcc4 Metrics Prometheus integration \ud83d\udcc4 \ud83d\udcc4"},{"location":"examples/#running-examples","title":"Running Examples","text":""},{"location":"examples/#python","title":"Python","text":"<pre><code># Clone repository\ngit clone https://github.com/scttfrdmn/agenkit.git\ncd agenkit\n\n# Install dependencies\npip install -e \".[dev]\"\n\n# Run any example\npython examples/01_basic_agent.py\npython examples/middleware/circuit_breaker_example.py\n</code></pre>"},{"location":"examples/#go","title":"Go","text":"<pre><code># Clone repository\ngit clone https://github.com/scttfrdmn/agenkit.git\ncd agenkit/agenkit-go/examples\n\n# Run any example\ngo run basic/main.go\ngo run middleware/circuit_breaker_example.go\n</code></pre>"},{"location":"examples/#learning-path","title":"Learning Path","text":"<p>Follow this order for the best learning experience:</p>"},{"location":"examples/#1-fundamentals-day-1","title":"1. Fundamentals (Day 1)","text":"<ul> <li>01_basic_agent.py</li> <li>02_sequential_pattern.py</li> <li>03_parallel_pattern.py</li> <li>04_router_pattern.py</li> <li>05_tool_usage.py</li> <li>06_pattern_composition.py</li> </ul>"},{"location":"examples/#2-transport-remote-day-2","title":"2. Transport &amp; Remote (Day 2)","text":"<ul> <li>adapters/01_basic_remote_agent.py</li> <li>transport/grpc_example.py</li> <li>transport/websocket_example.py</li> </ul>"},{"location":"examples/#3-production-middleware-day-3","title":"3. Production Middleware (Day 3)","text":"<ul> <li>middleware/retry_example.py</li> <li>middleware/timeout_example.py</li> <li>middleware/circuit_breaker_example.py</li> <li>middleware/rate_limiter_example.py</li> <li>middleware/caching_example.py</li> <li>middleware/batching_example.py</li> </ul>"},{"location":"examples/#4-observability-day-4","title":"4. Observability (Day 4)","text":"<ul> <li>middleware/metrics_example.py</li> <li>observability/observability_example.py</li> </ul>"},{"location":"examples/#5-advanced-day-5","title":"5. Advanced (Day 5)","text":"<ul> <li>composition/fallback_example.py</li> <li>composition/conditional_example.py</li> <li>tools/* (all tool examples)</li> </ul>"},{"location":"examples/#example-statistics","title":"Example Statistics","text":"<ul> <li>Total Examples: 28+ (Python) + 16 (Go) = 44+ examples</li> <li>Lines of Code: ~6,700 lines with documentation</li> <li>Coverage: All features demonstrated</li> <li>Maintenance: Updated with each release</li> </ul>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Run examples - Clone the repo and try them out</li> <li>Read guides - Deepen understanding with guides</li> <li>Build something - Use examples as templates</li> <li>Contribute - Share your examples with the community</li> </ul>"},{"location":"features/","title":"Features","text":"<p>Explore Agenkit's comprehensive feature set.</p>"},{"location":"features/#overview","title":"Overview","text":"<p>Agenkit provides production-ready features organized into five categories:</p> <ul> <li> <p> Transport Layer</p> <p>Connect agents across processes and languages with HTTP, gRPC, and WebSocket.</p> <p> Learn more</p> </li> <li> <p> Middleware</p> <p>Add resilience, caching, rate limiting, and observability with composable middleware.</p> <p> Learn more</p> </li> <li> <p> Composition</p> <p>Orchestrate multiple agents into workflows with sequential, parallel, and router patterns.</p> <p> Learn more</p> </li> <li> <p> Observability</p> <p>Full OpenTelemetry integration with distributed tracing and Prometheus metrics.</p> <p> Learn more</p> </li> <li> <p> Tools</p> <p>Extend agents with executable tools for deterministic operations.</p> <p> Learn more</p> </li> </ul>"},{"location":"features/#feature-matrix","title":"Feature Matrix","text":"Feature Python Go Cross-Language Transport Layer HTTP/1.1 \u2705 \u2705 \u2705 HTTP/2 \u2705 \u2705 \u2705 HTTP/3 (QUIC) \u2705 \u2705 \u2705 gRPC \u2705 \u2705 \u2705 WebSocket \u2705 \u2705 \u2705 Middleware Retry \u2705 \u2705 N/A Circuit Breaker \u2705 \u2705 N/A Timeout \u2705 \u2705 N/A Rate Limiter \u2705 \u2705 N/A Caching (LRU) \u2705 \u2705 N/A Batching \u2705 \u2705 N/A Composition Sequential \u2705 \u2705 \u2705 Parallel \u2705 \u2705 \u2705 Fallback \u2705 \u2705 \u2705 Conditional \u2705 \u2705 \u2705 Observability OpenTelemetry Tracing \u2705 \u2705 \u2705 W3C Trace Context \u2705 \u2705 \u2705 Prometheus Metrics \u2705 \u2705 \u2705 Structured Logging \u2705 \u2705 \u2705 Tools Tool Interface \u2705 \u2705 N/A Tool Registry \u2705 \u2705 N/A"},{"location":"features/#quick-examples","title":"Quick Examples","text":""},{"location":"features/#transport-layer","title":"Transport Layer","text":"<pre><code># HTTP\nagent = RemoteAgent(name=\"api\", endpoint=\"http://localhost:8080\")\n\n# gRPC\nagent = RemoteAgent(name=\"api\", endpoint=\"grpc://localhost:50051\")\n\n# WebSocket\nagent = RemoteAgent(name=\"api\", endpoint=\"ws://localhost:8080\")\n</code></pre>"},{"location":"features/#middleware","title":"Middleware","text":"<pre><code># Stack middleware\nagent = MyAgent()\nagent = CachingDecorator(agent, max_size=1000)\nagent = RetryDecorator(agent, max_attempts=3)\nagent = CircuitBreaker(agent)\nagent = TimeoutDecorator(agent, timeout=30.0)\n</code></pre>"},{"location":"features/#composition","title":"Composition","text":"<pre><code># Sequential pipeline\npipeline = SequentialAgent([validator, processor, formatter])\n\n# Parallel analysis\nanalysis = ParallelAgent([sentiment, summary, entities])\n\n# Router\nrouter = ConditionalAgent(\n    agents=[weather_agent, news_agent, general_agent],\n    condition=route_function\n)\n</code></pre>"},{"location":"features/#observability","title":"Observability","text":"<pre><code># Initialize tracing and metrics\ninit_tracing(\"my-service\", otlp_endpoint=\"http://jaeger:4317\")\ninit_metrics(\"my-service\", port=8001)\n\n# Wrap agent\nagent = TracingMiddleware(MetricsMiddleware(MyAgent()))\n</code></pre>"},{"location":"features/#performance","title":"Performance","text":"<p>All features are designed for production use with minimal overhead:</p> <ul> <li>Transport overhead: &lt;1% in realistic workloads</li> <li>Middleware overhead: &lt;0.01% per middleware</li> <li>Composition overhead: &lt;5% for sequential/parallel</li> <li>Observability overhead: &lt;2% with tracing enabled</li> </ul> <p>View detailed benchmarks \u2192</p>"},{"location":"features/#next-steps","title":"Next Steps","text":"<ul> <li>Transport Layer - Connect agents across boundaries</li> <li>Middleware - Add production resilience</li> <li>Composition - Build multi-agent workflows</li> <li>Observability - Monitor and debug</li> <li>Tools - Extend agent capabilities</li> </ul>"},{"location":"features/composition/","title":"Composition Patterns","text":"<p>Orchestrate multiple agents into workflows.</p> <p>Coming Soon</p> <p>Detailed composition documentation is being migrated. For now, see: - Architecture Guide - Examples - Source Code</p>"},{"location":"features/middleware/","title":"Middleware","text":"<p>Add resilience and observability to your agents.</p> <p>Coming Soon</p> <p>Detailed middleware documentation is being migrated. For now, see: - Architecture Guide - Examples - Source Code</p>"},{"location":"features/observability/","title":"Observability","text":"<p>Full OpenTelemetry integration for tracing, metrics, and logging.</p> <p>Coming Soon</p> <p>Detailed observability documentation is being migrated. For now, see: - Architecture Guide - Examples - Existing Docs</p>"},{"location":"features/tools/","title":"Tools","text":"<p>Extend agents with executable tools.</p> <p>Coming Soon</p> <p>Detailed tools documentation is being migrated. For now, see: - Interfaces Guide - Examples - Source Code</p>"},{"location":"features/transport/","title":"Transport Layer","text":"<p>Connect agents across processes and languages.</p> <p>Coming Soon</p> <p>Detailed transport layer documentation is being migrated. For now, see: - Architecture Guide - Examples - Source Code</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to Agenkit! This guide will help you get up and running quickly.</p>"},{"location":"getting-started/#what-is-agenkit","title":"What is Agenkit?","text":"<p>Agenkit is a production-ready framework for building distributed AI agent systems. It provides:</p> <ul> <li>Minimal, type-safe interfaces for agent communication</li> <li>Cross-language support (Python \u2194 Go)</li> <li>Multiple transport protocols (HTTP, gRPC, WebSocket)</li> <li>Production middleware (retry, circuit breaker, caching, etc.)</li> <li>Full observability (OpenTelemetry tracing + Prometheus metrics)</li> <li>Container-native deployment (Docker + Kubernetes)</li> </ul>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"PythonGo <ul> <li>Python 3.10 or higher</li> <li>pip package manager</li> </ul> <ul> <li>Go 1.21 or higher</li> <li>Go modules enabled</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Follow the installation guide for your language:</p> <p>\u2192 Python Installation \u2192 Go Installation</p>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":"<p>Once installed, follow the quick start guide to build your first agent:</p> <p>\u2192 Quick Start Tutorial</p>"},{"location":"getting-started/#whats-next","title":"What's Next?","text":"<p>After completing the quick start:</p> <ol> <li>Learn the core concepts - Understand the architecture and design principles</li> <li>Explore features - Check out middleware, composition, and observability</li> <li>Follow guides - Build production-ready systems with our Python guide or Go guide</li> <li>Browse examples - See 28+ examples covering all features</li> </ol>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: You're reading it!</li> <li>GitHub Issues: Report bugs</li> <li>Discussions: Ask questions</li> </ul>"},{"location":"getting-started/first-agent/","title":"Build Your First Agent","text":"<p>This tutorial walks you through building a practical agent step-by-step.</p>"},{"location":"getting-started/first-agent/#the-agent-well-build","title":"The Agent We'll Build","text":"<p>We'll create a Text Analyzer Agent that: - Counts words in a message - Detects sentiment (positive/negative/neutral) - Returns structured analysis</p>"},{"location":"getting-started/first-agent/#step-1-create-the-agent-class","title":"Step 1: Create the Agent Class","text":"PythonGo <pre><code>from agenkit import Agent, Message\nfrom typing import Dict, Any\n\nclass TextAnalyzerAgent(Agent):\n    @property\n    def name(self) -&gt; str:\n        return \"text-analyzer\"\n\n    @property\n    def capabilities(self) -&gt; list[str]:\n        return [\"text-analysis\", \"sentiment\", \"word-count\"]\n\n    async def process(self, message: Message) -&gt; Message:\n        # We'll implement this next\n        pass\n</code></pre> <pre><code>package main\n\nimport (\n    \"context\"\n    \"github.com/agenkit/agenkit-go/agenkit\"\n)\n\ntype TextAnalyzerAgent struct{}\n\nfunc (a *TextAnalyzerAgent) Name() string {\n    return \"text-analyzer\"\n}\n\nfunc (a *TextAnalyzerAgent) Capabilities() []string {\n    return []string{\"text-analysis\", \"sentiment\", \"word-count\"}\n}\n\nfunc (a *TextAnalyzerAgent) Process(ctx context.Context, msg *agenkit.Message) (*agenkit.Message, error) {\n    // We'll implement this next\n    return nil, nil\n}\n</code></pre>"},{"location":"getting-started/first-agent/#step-2-implement-word-counting","title":"Step 2: Implement Word Counting","text":"PythonGo <pre><code>def _count_words(self, text: str) -&gt; int:\n    \"\"\"Count words in the text.\"\"\"\n    return len(text.split())\n\ndef _analyze_sentiment(self, text: str) -&gt; str:\n    \"\"\"Simple sentiment analysis.\"\"\"\n    text_lower = text.lower()\n\n    positive_words = ['good', 'great', 'excellent', 'happy', 'love']\n    negative_words = ['bad', 'terrible', 'awful', 'sad', 'hate']\n\n    positive_count = sum(1 for word in positive_words if word in text_lower)\n    negative_count = sum(1 for word in negative_words if word in text_lower)\n\n    if positive_count &gt; negative_count:\n        return \"positive\"\n    elif negative_count &gt; positive_count:\n        return \"negative\"\n    else:\n        return \"neutral\"\n</code></pre> <pre><code>import \"strings\"\n\nfunc (a *TextAnalyzerAgent) countWords(text string) int {\n    return len(strings.Fields(text))\n}\n\nfunc (a *TextAnalyzerAgent) analyzeSentiment(text string) string {\n    textLower := strings.ToLower(text)\n\n    positiveWords := []string{\"good\", \"great\", \"excellent\", \"happy\", \"love\"}\n    negativeWords := []string{\"bad\", \"terrible\", \"awful\", \"sad\", \"hate\"}\n\n    positiveCount := 0\n    for _, word := range positiveWords {\n        if strings.Contains(textLower, word) {\n            positiveCount++\n        }\n    }\n\n    negativeCount := 0\n    for _, word := range negativeWords {\n        if strings.Contains(textLower, word) {\n            negativeCount++\n        }\n    }\n\n    if positiveCount &gt; negativeCount {\n        return \"positive\"\n    } else if negativeCount &gt; positiveCount {\n        return \"negative\"\n    }\n    return \"neutral\"\n}\n</code></pre>"},{"location":"getting-started/first-agent/#step-3-complete-the-process-method","title":"Step 3: Complete the Process Method","text":"PythonGo <pre><code>async def process(self, message: Message) -&gt; Message:\n    # Extract text from message\n    text = str(message.content)\n\n    # Analyze the text\n    word_count = self._count_words(text)\n    sentiment = self._analyze_sentiment(text)\n\n    # Create response with analysis\n    analysis = {\n        \"word_count\": word_count,\n        \"sentiment\": sentiment,\n        \"text_preview\": text[:50] + \"...\" if len(text) &gt; 50 else text\n    }\n\n    return Message(\n        role=\"agent\",\n        content=analysis,\n        metadata={\n            \"agent\": self.name,\n            \"analysis_type\": \"text\"\n        }\n    )\n</code></pre> <pre><code>func (a *TextAnalyzerAgent) Process(ctx context.Context, msg *agenkit.Message) (*agenkit.Message, error) {\n    // Extract text from message\n    text := fmt.Sprintf(\"%v\", msg.Content)\n\n    // Analyze the text\n    wordCount := a.countWords(text)\n    sentiment := a.analyzeSentiment(text)\n\n    // Create response with analysis\n    analysis := map[string]interface{}{\n        \"word_count\": wordCount,\n        \"sentiment\":  sentiment,\n        \"text_preview\": text,\n    }\n\n    if len(text) &gt; 50 {\n        analysis[\"text_preview\"] = text[:50] + \"...\"\n    }\n\n    return &amp;agenkit.Message{\n        Role:    \"agent\",\n        Content: analysis,\n        Metadata: map[string]interface{}{\n            \"agent\":         a.Name(),\n            \"analysis_type\": \"text\",\n        },\n    }, nil\n}\n</code></pre>"},{"location":"getting-started/first-agent/#step-4-test-your-agent","title":"Step 4: Test Your Agent","text":"PythonGo <pre><code>import asyncio\n\nasync def main():\n    # Create the agent\n    agent = TextAnalyzerAgent()\n\n    # Test messages\n    test_messages = [\n        \"This is a great and excellent day!\",\n        \"I feel terrible and sad about this.\",\n        \"The weather is normal today.\"\n    ]\n\n    for text in test_messages:\n        message = Message(role=\"user\", content=text)\n        response = await agent.process(message)\n\n        print(f\"\\nInput: {text}\")\n        print(f\"Analysis: {response.content}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Output: <pre><code>Input: This is a great and excellent day!\nAnalysis: {'word_count': 7, 'sentiment': 'positive', 'text_preview': 'This is a great and excellent day!'}\n\nInput: I feel terrible and sad about this.\nAnalysis: {'word_count': 7, 'sentiment': 'negative', 'text_preview': 'I feel terrible and sad about this.'}\n\nInput: The weather is normal today.\nAnalysis: {'word_count': 5, 'sentiment': 'neutral', 'text_preview': 'The weather is normal today.'}\n</code></pre></p> <pre><code>func main() {\n    agent := &amp;TextAnalyzerAgent{}\n\n    testMessages := []string{\n        \"This is a great and excellent day!\",\n        \"I feel terrible and sad about this.\",\n        \"The weather is normal today.\",\n    }\n\n    for _, text := range testMessages {\n        message := &amp;agenkit.Message{\n            Role:    \"user\",\n            Content: text,\n        }\n\n        response, err := agent.Process(context.Background(), message)\n        if err != nil {\n            panic(err)\n        }\n\n        fmt.Printf(\"\\nInput: %s\\n\", text)\n        fmt.Printf(\"Analysis: %+v\\n\", response.Content)\n    }\n}\n</code></pre>"},{"location":"getting-started/first-agent/#step-5-add-error-handling","title":"Step 5: Add Error Handling","text":"PythonGo <pre><code>async def process(self, message: Message) -&gt; Message:\n    try:\n        # Validate input\n        if not message.content:\n            return Message(\n                role=\"agent\",\n                content={\"error\": \"Empty message content\"},\n                metadata={\"status\": \"error\"}\n            )\n\n        text = str(message.content)\n\n        # Analyze\n        word_count = self._count_words(text)\n        sentiment = self._analyze_sentiment(text)\n\n        analysis = {\n            \"word_count\": word_count,\n            \"sentiment\": sentiment,\n            \"text_preview\": text[:50] + \"...\" if len(text) &gt; 50 else text\n        }\n\n        return Message(\n            role=\"agent\",\n            content=analysis,\n            metadata={\"agent\": self.name, \"status\": \"success\"}\n        )\n\n    except Exception as e:\n        return Message(\n            role=\"agent\",\n            content={\"error\": str(e)},\n            metadata={\"status\": \"error\"}\n        )\n</code></pre> <pre><code>func (a *TextAnalyzerAgent) Process(ctx context.Context, msg *agenkit.Message) (*agenkit.Message, error) {\n    // Validate input\n    if msg.Content == nil || msg.Content == \"\" {\n        return &amp;agenkit.Message{\n            Role:    \"agent\",\n            Content: map[string]interface{}{\"error\": \"Empty message content\"},\n            Metadata: map[string]interface{}{\"status\": \"error\"},\n        }, nil\n    }\n\n    text := fmt.Sprintf(\"%v\", msg.Content)\n\n    // Analyze\n    wordCount := a.countWords(text)\n    sentiment := a.analyzeSentiment(text)\n\n    analysis := map[string]interface{}{\n        \"word_count\":   wordCount,\n        \"sentiment\":    sentiment,\n        \"text_preview\": text,\n    }\n\n    if len(text) &gt; 50 {\n        analysis[\"text_preview\"] = text[:50] + \"...\"\n    }\n\n    return &amp;agenkit.Message{\n        Role:    \"agent\",\n        Content: analysis,\n        Metadata: map[string]interface{}{\n            \"agent\":  a.Name(),\n            \"status\": \"success\",\n        },\n    }, nil\n}\n</code></pre>"},{"location":"getting-started/first-agent/#complete","title":"\ud83c\udf89 Complete!","text":"<p>You've built a fully functional text analyzer agent!</p>"},{"location":"getting-started/first-agent/#what-you-learned","title":"What You Learned","text":"<p>\u2705 Implementing the <code>Agent</code> interface \u2705 Processing messages and returning responses \u2705 Using metadata for extra information \u2705 Error handling in agents \u2705 Testing your agent</p>"},{"location":"getting-started/first-agent/#next-steps","title":"Next Steps","text":"<ul> <li>Add middleware - Wrap your agent with retry or caching</li> <li>Compose agents - Combine multiple agents using composition patterns</li> <li>Go remote - Connect agents across processes with transports</li> <li>Add observability - Track performance with tracing and metrics</li> </ul> <p>Explore more in our Examples section!</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#python","title":"Python Installation","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<p>The easiest way to install Agenkit is via pip:</p> <pre><code>pip install agenkit\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<p>For development or to get the latest changes:</p> <pre><code># Clone the repository\ngit clone https://github.com/scttfrdmn/agenkit.git\ncd agenkit\n\n# Install in development mode with all dependencies\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>import agenkit\nprint(agenkit.__version__)\n</code></pre>"},{"location":"getting-started/installation/#go","title":"Go Installation","text":""},{"location":"getting-started/installation/#using-go-get","title":"Using go get","text":"<pre><code>go get github.com/agenkit/agenkit-go\n</code></pre>"},{"location":"getting-started/installation/#from-source_1","title":"From Source","text":"<pre><code># Clone the repository\ngit clone https://github.com/scttfrdmn/agenkit.git\ncd agenkit/agenkit-go\n\n# Download dependencies\ngo mod download\n\n# Run tests to verify\ngo test ./...\n</code></pre>"},{"location":"getting-started/installation/#verify-installation_1","title":"Verify Installation","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/agenkit/agenkit-go/agenkit\"\n)\n\nfunc main() {\n    fmt.Println(\"Agenkit for Go installed successfully!\")\n}\n</code></pre>"},{"location":"getting-started/installation/#docker-installation","title":"Docker Installation","text":"<p>Pull the official Docker images:</p> Python ImageGo ImageDocker Compose <pre><code>docker pull agenkit/python:1.0.0\n</code></pre> <pre><code>docker pull agenkit/go:1.0.0\n</code></pre> <pre><code># Clone repository\ngit clone https://github.com/scttfrdmn/agenkit.git\ncd agenkit\n\n# Start full stack\ndocker-compose up -d\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"getting-started/installation/#for-observability","title":"For Observability","text":"PythonGo <pre><code># Install OpenTelemetry dependencies\npip install opentelemetry-api opentelemetry-sdk\npip install opentelemetry-exporter-otlp\npip install prometheus-client\n</code></pre> <pre><code># Already included in go.mod\ngo get go.opentelemetry.io/otel\ngo get github.com/prometheus/client_golang\n</code></pre>"},{"location":"getting-started/installation/#for-grpc-transport","title":"For gRPC Transport","text":"PythonGo <pre><code>pip install grpcio grpcio-tools\n</code></pre> <pre><code>go get google.golang.org/grpc\n</code></pre>"},{"location":"getting-started/installation/#for-http3-support","title":"For HTTP/3 Support","text":"PythonGo <pre><code>pip install aioquic\n</code></pre> <pre><code>go get github.com/quic-go/quic-go\n</code></pre>"},{"location":"getting-started/installation/#development-dependencies","title":"Development Dependencies","text":"<p>For contributing or running tests:</p> PythonGo <pre><code># Install development dependencies\npip install -e \".[dev]\"\n\n# This includes:\n# - pytest (testing)\n# - mypy (type checking)\n# - black (formatting)\n# - ruff (linting)\n# - hypothesis (property-based testing)\n</code></pre> <pre><code># Install golangci-lint\ngo install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n\n# Run tests\ngo test ./...\n\n# Run linter\ngolangci-lint run\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have Agenkit installed, proceed to the Quick Start guide to build your first agent!</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Build your first Agenkit agent in less than 5 minutes!</p>"},{"location":"getting-started/quick-start/#your-first-agent","title":"Your First Agent","text":"PythonGo <p>Create a file <code>my_agent.py</code>:</p> <pre><code>from agenkit import Agent, Message\nimport asyncio\n\nclass EchoAgent(Agent):\n    \"\"\"A simple agent that echoes messages.\"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        return \"echo-agent\"\n\n    @property\n    def capabilities(self) -&gt; list[str]:\n        return [\"echo\", \"text-processing\"]\n\n    async def process(self, message: Message) -&gt; Message:\n        \"\"\"Process the message and return a response.\"\"\"\n        response_content = f\"Echo: {message.content}\"\n        return Message(\n            role=\"agent\",\n            content=response_content,\n            metadata={\"processed_by\": self.name}\n        )\n\n# Use the agent\nasync def main():\n    agent = EchoAgent()\n\n    # Create a message\n    user_message = Message(\n        role=\"user\",\n        content=\"Hello, Agenkit!\"\n    )\n\n    # Process it\n    response = await agent.process(user_message)\n    print(f\"Agent: {response.content}\")\n    # Output: \"Agent: Echo: Hello, Agenkit!\"\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Run it: <pre><code>python my_agent.py\n</code></pre></p> <p>Create a file <code>my_agent.go</code>:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/agenkit/agenkit-go/agenkit\"\n)\n\n// EchoAgent is a simple agent that echoes messages\ntype EchoAgent struct{}\n\nfunc (a *EchoAgent) Name() string {\n    return \"echo-agent\"\n}\n\nfunc (a *EchoAgent) Capabilities() []string {\n    return []string{\"echo\", \"text-processing\"}\n}\n\nfunc (a *EchoAgent) Process(ctx context.Context, msg *agenkit.Message) (*agenkit.Message, error) {\n    responseContent := fmt.Sprintf(\"Echo: %s\", msg.Content)\n\n    return &amp;agenkit.Message{\n        Role:    \"agent\",\n        Content: responseContent,\n        Metadata: map[string]interface{}{\n            \"processed_by\": a.Name(),\n        },\n    }, nil\n}\n\nfunc main() {\n    agent := &amp;EchoAgent{}\n\n    // Create a message\n    userMessage := &amp;agenkit.Message{\n        Role:    \"user\",\n        Content: \"Hello, Agenkit!\",\n    }\n\n    // Process it\n    response, err := agent.Process(context.Background(), userMessage)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"Agent: %s\\n\", response.Content)\n    // Output: \"Agent: Echo: Hello, Agenkit!\"\n}\n</code></pre> <p>Run it: <pre><code>go run my_agent.go\n</code></pre></p>"},{"location":"getting-started/quick-start/#understanding-the-code","title":"Understanding the Code","text":""},{"location":"getting-started/quick-start/#1-the-agent-interface","title":"1. The Agent Interface","text":"<p>Every agent implements the <code>Agent</code> interface with two required methods:</p> <ul> <li><code>name</code> - A unique identifier for the agent</li> <li><code>process(message)</code> - The core method that processes messages</li> </ul>"},{"location":"getting-started/quick-start/#2-the-message-type","title":"2. The Message Type","text":"<p>Messages are the universal data format in Agenkit:</p> <pre><code>Message(\n    role=\"user\",           # Who sent it: \"user\", \"agent\", \"system\", \"tool\"\n    content=\"...\",         # The actual content (any type)\n    metadata={}            # Optional metadata dict\n)\n</code></pre>"},{"location":"getting-started/quick-start/#3-processing-flow","title":"3. Processing Flow","text":"<pre><code>User Message \u2192 Agent.process() \u2192 Agent Response\n</code></pre> <p>Simple as that!</p>"},{"location":"getting-started/quick-start/#adding-middleware","title":"Adding Middleware","text":"<p>Let's add retry logic to make our agent more resilient:</p> PythonGo <pre><code>from agenkit.middleware import RetryDecorator, RetryConfig\n\n# Create the agent\nagent = EchoAgent()\n\n# Wrap with retry middleware\nresilient_agent = RetryDecorator(\n    agent,\n    RetryConfig(\n        max_attempts=3,\n        initial_backoff=1.0\n    )\n)\n\n# Use it (retries automatically on failure)\nresponse = await resilient_agent.process(message)\n</code></pre> <pre><code>import \"github.com/agenkit/agenkit-go/middleware\"\n\n// Create the agent\nagent := &amp;EchoAgent{}\n\n// Wrap with retry middleware\nresilientAgent := middleware.NewRetryDecorator(\n    agent,\n    middleware.RetryConfig{\n        MaxAttempts:     3,\n        InitialBackoff:  time.Second,\n    },\n)\n\n// Use it (retries automatically on failure)\nresponse, _ := resilientAgent.Process(ctx, message)\n</code></pre>"},{"location":"getting-started/quick-start/#remote-communication","title":"Remote Communication","text":"<p>Connect to a remote agent over HTTP:</p> PythonGo <pre><code>from agenkit.adapters.python.remote_agent import RemoteAgent\n\n# Connect to remote agent\nremote_agent = RemoteAgent(\n    name=\"remote-echo\",\n    endpoint=\"http://localhost:8080\"\n)\n\n# Use it exactly like a local agent!\nresponse = await remote_agent.process(message)\n</code></pre> <pre><code>import \"github.com/agenkit/agenkit-go/adapter/http\"\n\n// Connect to remote agent\nremoteAgent := http.NewHTTPAgent(\n    \"remote-echo\",\n    \"http://localhost:8080\",\n)\n\n// Use it exactly like a local agent!\nresponse, _ := remoteAgent.Process(ctx, message)\n</code></pre>"},{"location":"getting-started/quick-start/#composition","title":"Composition","text":"<p>Combine multiple agents into a workflow:</p> PythonGo <pre><code>from agenkit.composition import SequentialAgent\n\n# Create a pipeline: validator \u2192 processor \u2192 formatter\npipeline = SequentialAgent([\n    ValidatorAgent(),\n    ProcessorAgent(),\n    FormatterAgent()\n])\n\n# Process flows through all three\nresult = await pipeline.process(message)\n</code></pre> <pre><code>import \"github.com/agenkit/agenkit-go/composition\"\n\n// Create a pipeline\npipeline := composition.NewSequentialAgent([]agenkit.Agent{\n    &amp;ValidatorAgent{},\n    &amp;ProcessorAgent{},\n    &amp;FormatterAgent{},\n})\n\n// Process flows through all three\nresult, _ := pipeline.Process(ctx, message)\n</code></pre>"},{"location":"getting-started/quick-start/#whats-next","title":"What's Next?","text":"<p>\ud83c\udf89 Congratulations! You've built your first Agenkit agent.</p> <p>Continue learning:</p> <ul> <li>Architecture - Understand how the layers work together</li> <li>Middleware Guide - Add resilience and observability</li> <li>Composition Patterns - Build multi-agent workflows</li> <li>Examples - Explore 28+ comprehensive examples</li> </ul> <p>Ready for production?</p> <ul> <li>Deployment Guide - Deploy with Docker and Kubernetes</li> <li>Observability Guide - Add tracing and metrics</li> <li>Best Practices - Production patterns and tips</li> </ul>"},{"location":"guides/","title":"Guides","text":"<p>Step-by-step guides for common tasks.</p>"},{"location":"guides/#available-guides","title":"Available Guides","text":"<ul> <li>Python Guide - Building agents in Python</li> <li>Go Guide - Building agents in Go</li> <li>Cross-Language Guide - Python \u2194 Go communication</li> <li>Deployment Guide - Production deployment</li> <li>Best Practices - Production patterns</li> </ul> <p>In Progress</p> <p>Guides are being written. Check back soon!</p>"},{"location":"guides/best-practices/","title":"Guide","text":"<p>Coming Soon</p> <p>This guide is being written.</p>"},{"location":"guides/cross-language/","title":"Guide","text":"<p>Coming Soon</p> <p>This guide is being written.</p>"},{"location":"guides/deployment/","title":"Guide","text":"<p>Coming Soon</p> <p>This guide is being written.</p>"},{"location":"guides/go/","title":"Guide","text":"<p>Coming Soon</p> <p>This guide is being written.</p>"},{"location":"guides/python/","title":"Python Guide","text":"<p>Building agents in Python.</p> <p>Coming Soon</p> <p>This guide is being written.</p>"},{"location":"performance/","title":"Performance","text":"<p>Agenkit performance characteristics and benchmarks.</p>"},{"location":"performance/#overview","title":"Overview","text":"<p>Agenkit is designed for production use with minimal overhead.</p>"},{"location":"performance/#key-metrics","title":"Key Metrics","text":"<ul> <li>Transport overhead: &lt;1% in realistic LLM workloads</li> <li>Middleware overhead: &lt;0.01% per middleware</li> <li>Go HTTP: 18.5x faster than Python (0.055ms vs 1.02ms)</li> <li>Message scaling: 10,000x size = 190x latency</li> </ul>"},{"location":"performance/#detailed-benchmarks","title":"Detailed Benchmarks","text":"<p>See Benchmarks for detailed performance data.</p>"},{"location":"performance/benchmarks/","title":"Benchmarks","text":"<p>Detailed performance benchmarks.</p> <p>Coming Soon</p> <p>Detailed benchmark documentation is being migrated. For now, see: - benchmarks/BASELINES.md</p>"}]}